//// COMPUTE THE BITWISE EXCLUSIVE OR.
// This function takes two arguments and pushes the exclusive
// OR of its bits onto the stack. This function implements the
// formula:
//    x XOR y = (x AND (NOT y)) OR ((NOT x) and y)
// To call this function, you should:
//   1. push the two arguments onto the stack; and
//   2. call this function with `call Sys.xor 2`.
// Before returning, the function pushes the result onto the
// stack, so that, from the point of view of the callee, the
// result is at the top of the stack.
//
function Sys.xor 0
    // Your implementation goes here.
    // Get the two arguments
    push argument 0
    push argument 1
    
    // First part: (x AND (NOT y))
    push argument 0
    push argument 1
    not
    and
    
    // Second part: ((NOT x) AND y)
    push argument 0
    not
    push argument 1
    and
    
    // Combine with OR: (x AND (NOT y)) OR ((NOT x) AND y)
    or    
    return



//// SHIFT A VALUE LEFT BY REPEATED ADDITION.
// This function takes two arguments and pushes the first argument
// shifted left by as many position as indicated by the second
// argument. To call this function, you should:
//   1. push the two arguments (number to be shifted and number of
//      shift positions) onto the stack; and
//   2. call this function with `call Sys.shiftLeft 2`.
// Before returning, the function pushes the result onto the
// stack, so that, from the point of view of the callee, the
// result is at the top of the stack.
//
function Sys.shiftLeft 2
    // Your implementation goes here.
    // Store the value to shift in local 0
    push argument 0
    pop local 0
    
    // Store the shift count in local 1
    push argument 1
    pop local 1
    
    // Check if shift count is 0
    push local 1
    push constant 0
    eq
    if-goto RETURN_VALUE
    
    // Loop to shift left by doubling the value
label SHIFT_LOOP
    // Check if we've done all shifts
    push local 1
    push constant 0
    eq
    if-goto RETURN_VALUE
    
    // Double the value (shift left by 1)
    push local 0
    push local 0
    add
    pop local 0
    
    // Decrement the shift counter
    push local 1
    push constant 1
    sub
    pop local 1
    
    goto SHIFT_LOOP
    
label RETURN_VALUE
    push local 0    
    return



//// COMPUTE THE PARITY OF THE BOTTOM 15 BITS OF AN INTEGER.
// This function takes one arguments and pushes the parity of
// the fifteen right-most bits onto the stack. The possible output
// values are 1, if the number of 1s in the right-most fifteen
// bits is odd, or 0, if the number of 1s in the right-most
// fifteen bits is even. Here is some example output:
//
//     INPUT (binary)  | OUT |         NOTES
//    -----------------+-----+-----------------------
//    1000000000000000 |  0  | Left-most bit ignored.
//    0000000000000001 |  1  |
//    1000000000000001 |  1  | Left-most bit ignored.
//    0111111111011111 |  0  |
//    0111111111111111 |  1  |
//    1111111111111111 |  1  | Left-most bit ignored.
//
// To call this function, you should:
//   1. push the argument onto the stack; and
//   2. call this function with `call Sys.computeParity 1`.
// Before returning, the function pushes the result onto the
// stack, so that, from the point of view of the callee, the
// result is at the top of the stack.
//
function Sys.computeParity 2
    // Your implementation goes here.
    // Store the input in local 0
    push argument 0
    pop local 0
    
    // Initialize parity bit to 0
    push constant 0
    pop local 1
    
    // Loop through all 15 bits (ignoring the leftmost bit)
    push constant 0
    pop temp 0  // Loop counter i
    
label PARITY_LOOP
    // Check if we've checked all 15 bits
    push temp 0
    push constant 15
    eq
    if-goto RETURN_PARITY
    
    // Create bitmask (1 << i)
    push constant 1
    push temp 0
    call Sys.shiftLeft 2
    
    // Get ith bit (input & bitmask)
    push local 0
    and
    
    // Check if ith bit is set (not equal to 0)
    push constant 0
    eq
    not
    if-goto BIT_IS_SET
    
    // Bit is not set, continue to next bit
    goto NEXT_BIT
    
label BIT_IS_SET
    // Toggle the parity bit
    push local 1
    push constant 1
    call Sys.xor 2
    pop local 1
    
label NEXT_BIT
    // Increment counter
    push temp 0
    push constant 1
    add
    pop temp 0
    
    goto PARITY_LOOP
    
label RETURN_PARITY
    push local 1    
    return


//// SET LEFT-MOST BIT TO PARITY BIT.
// This function takes one 16-bit string and pushes onto the stack
// the same bit string with the left-most bit set to the parity
// bit of the 15 right-most bits. Here is some example output:
//
//     INPUT (binary)  | OUTPUT (binary)  |         NOTES
//    -----------------+------------------+-----------------------
//    1000000000000000 | 0000000000000000 | Left-most bit ignored.
//    0000000000000001 | 1000000000000001 |
//    1000000000000001 | 1000000000000001 | Left-most bit ignored.
//    0111111111011111 | 0111111111011111 |
//    0111111111111111 | 1111111111111111 |
//    1111111111111111 | 1111111111111111 | Left-most bit ignored.
//
// To call this function, you should:
//   1. push the the argument onto the stack; and
//   2. call this function with `call Sys.encode 1`.
// Before returning, the function pushes the result onto the
// stack, so that, from the point of view of the callee, the
// result is at the top of the stack.
//
function Sys.encode 0
    // Your implementation goes here.
    // Clear the most significant bit
    push constant 0
    push constant 15 
    call Sys.shiftLeft 2    // Create mask 1000000000000000
    not                     // Invert to 0111111111111111
    push argument 0
    and                     // Clear the MSB of the input
    
    // Compute the parity
    push argument 0
    call Sys.computeParity 1
    
    // Check if parity is 1
    push constant 0
    eq
    not
    if-goto SET_MSB
    
    // Parity is 0, just return the value with MSB cleared
    goto RETURN_RESULT
    
label SET_MSB
    // Set the most significant bit
    push constant 0
    push constant 15
    call Sys.shiftLeft 2    // Create mask 1000000000000000
    or                      // Set MSB
    
label RETURN_RESULT    
    return



// The emulator will start executing from here. You can modify
// the code below while testing and debugging your code, but
// please revert your changes before submitting to Gradescope;
// otherwise, your submission will most likely fail all tests.
//
// A better way to test your code is to use the supplied file
//   Sys.tst
// with the virtual machine emulator. Please do not submit this
// file to Gradescope, as this will cause your submission to be
// rejected.
//
function Sys.init 0
    call Sys.encode 1

label WHILE
    goto WHILE